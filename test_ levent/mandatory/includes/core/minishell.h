

/**
 * @file minishell.h
 * @brief Central header including all necessary
 * submodules and standard system headers for the minishell project.
 *
 * TODO:
 * - Implement main program logic in main.c
 * - Initialize all members of t_minishell
 * - Free everything properly at the end
 * - Handle signal setup and reset
 */
#ifndef MINISHELL_H
# define MINISHELL_H

# include "../../../libft/inc/libft.h"
# include "../../../libft/garbage_collector/inc/garbage_collector.h"
# include "command_tree.h"
# include <errno.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <sys/signal.h>
# include <sys/types.h>
# include <sys/wait.h>

typedef enum e_gc_type
{
    GC_MAIN,     // Persistent shell data (environment, history, etc.)
    GC_COMMAND,  // Per-command execution data
	GC_TEMP,	 // Temporary allocations
	GC_ENV,      // value and content allocations
	GC_CWD,
    GC_COUNT     // Number of GC categories (used for array size)
} t_gc_type;

typedef struct s_minishell
{
	t_list *envp;         // Linked list of t_env for environment variables
	char **envp_arr;      // Array of environment variables for execve
	t_list *token_list;   // List of tokens generated by lexer
	t_command_tree *root; // AST root for command execution
	char *input;          // Raw user input line
	char *cwd;            // Current working directory
	int exit_code;        // Exit code of last executed command
	int last_signal;      // Last received signal (used for signal handling)
	t_gc *gc[GC_COUNT];   // Array of garbage collectors
}	t_minishell;

# include "builtins.h"
# include "environment.h"
# include "execution.h"
# include "token.h"

#endif
